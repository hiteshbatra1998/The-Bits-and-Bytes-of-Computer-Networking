------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********
Linux Boot-up Process

An operating system (OS) is the low-level software that manages resources, controls peripherals, and provides basic services to other software.
In Linux, there are 6 distinct stages in the typical booting process.

1. BIOS - BIOS is firmware used to perform hardware initialization during the booting process, and to provide runtime services for operating systems and programs. 
          The BIOS firmware comes pre-installed on a personal computer's system board, and it is the first software to run when powered on. 

- BIOS stands for Basic Input/Output System
- Performs some system integrity checks
- Searches, loads, and executes the boot loader program.
- It looks for boot loader in floppy, cd-rom, or hard drive. You can press a key F12 of F2 during the BIOS startup to change the boot sequence.
- Once the boot loader program is detected and loaded into the memory, BIOS gives the control to it.
- So, in simple terms BIOS loads and executes the MBR boot loader.  

2. MBR
- MBR stands for Master Boot Record.
- It is located in the 1st sector of the bootable disk. Typically /dev/hda, or /dev/sda
- MBR is less than 512 bytes in size. This has three components 
    1) primary boot loader info in 1st 446 bytes 
    2) partition table info in next 64 bytes 
    3) mbr validation check in last 2 bytes.
- It contains information about GRUB (or LILO in old systems).
- So, in simple terms MBR loads and executes the GRUB boot loader.
- The MBR is the first sector of the computer hard drive that tells the computer how to load the operating system, 
  how the hard drive is partitioned.

3. GRUB/ LILO (Linux Loader)
- GRUB stands for Grand Unified Bootloader.
- If you have multiple kernel images installed on your system, you can choose which one to be executed.
- GRUB displays a splash screen, waits for few seconds, if you don’t enter anything, it loads the default kernel image as specified in the grub configuration file.
- GRUB has the knowledge of the filesystem (the older Linux loader LILO didn’t understand filesystem).
- Grub configuration file is /boot/grub/grub.conf (/etc/grub.conf is a link to this). 
- So, in simple terms GRUB just loads and executes Kernel and initrd images.

4. Kernel
  The Linux® kernel is the main component of a Linux operating system (OS) and is the core interface between a computer's hardware and its processes. It 
  communicates between the 2, managing resources as efficiently as possible.
- Mounts the root file system as specified in the “root=” in grub.conf
- Kernel executes the /sbin/init program
- Since init was the 1st program to be executed by Linux Kernel, it has the process id (PID) of 1.
- initrd stands for Initial RAM Disk.
- initrd is used by kernel as temporary root file system until kernel is booted and the real root file system is mounted. It also contains necessary drivers 
  compiled inside, which helps it to access the hard drive partitions, and other hardware.
- The kernel, if compressed (vmlinuz), will decompress itself. It then sets up system functions such as essential hardware and memory paging, and calls start_kernel() 
  which performs the majority of system setup (interrupts, the rest of memory management, device and driver initialization, etc.). 
  
5. Init
- Init is the parent of all processes, executed by the kernel during the booting of a system. Its principle role is to create processes from a script stored 
  in the file /etc/inittab.
- Looks at the /etc/inittab file to decide the Linux run level.
- Following are the available run levels
    0 – halt
    1 – Single user mode
    2 – Multiuser, without NFS
    3 – Full multiuser mode
    4 – unused
    5 – X11
    6 – reboot
- Init identifies the default initlevel from /etc/inittab and uses that to load all appropriate program.
- Execute ‘grep initdefault /etc/inittab’ on your system to identify the default run level
- Typically you would set the default run level to either 3 or 5.

6. Runlevel programs
- When the Linux system is booting up, you might see various services getting started. For example, it might say “starting sendmail …. OK”. Those are the 
  runlevel programs, executed from the run level directory as defined by your run level.
- Depending on your default init level setting, the system will execute the programs from one of the following directories.
    Run level 0 – /etc/rc.d/rc0.d/
    Run level 1 – /etc/rc.d/rc1.d/
    Run level 2 – /etc/rc.d/rc2.d/
    Run level 3 – /etc/rc.d/rc3.d/
    Run level 4 – /etc/rc.d/rc4.d/
    Run level 5 – /etc/rc.d/rc5.d/
    Run level 6 – /etc/rc.d/rc6.d/
- Programs starts with S are used during startup. S for startup.
- Programs starts with K are used during shutdown. K for kill.    
- A runlevel in other words can be defined as a preset single digit integer for defining the operating state of your LINUX or UNIX-based operating system. 
  Each runlevel designates a different system configuration and allows access to different combination of processes.  
  
 ** Unified Extensible Firmware Interface (UEFI) replaces BIOS.
    UEFI is packed with other features. It supports Secure Boot, which means the operating system can be checked for validity to ensure no malware has tampered 
    with the boot process. It can support networking features right in the UEFI firmware itself, which can aid in remote troubleshooting and configuration.  

------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********  
- An Operating System (OS) is an interface between a computer user and computer hardware. An operating system is a software which performs all the basic tasks like 
  file management, memory management, process management, handling input and output, and controlling peripheral devices such as disk drives and printers.

- https://www.tutorialspoint.com/operating_system/index.htm

*****************
Memory Management:
- Memory management is the functionality of an operating system which handles or manages primary memory and moves processes back and forth between main memory and 
  disk during execution. Memory management keeps track of each and every memory location, regardless of either it is allocated to some process or it is free. 
  It checks how much memory is to be allocated to processes. It decides which process will get memory at what time. It tracks whenever some memory gets freed or 
  unallocated and correspondingly it updates the status.

- https://www.geeksforgeeks.org/logical-and-physical-address-in-operating-system/#:~:text=Logical%20Address%20is%20generated%20by%20CPU%20while%20a%20program%20is%20running.&text=Physical%20Address%20identifies%20a%20physical,by%20its%20corresponding%20logical%20address.
- Virtual and physical addresses are the same in compile-time and load-time address-binding schemes. 
  Virtual and physical addresses differ in execution-time address-binding scheme.
- The set of all logical addresses generated by a program is referred to as a logical address space. The set of all physical addresses corresponding to these 
  logical addresses is referred to as a physical address space.
- The runtime mapping from virtual to physical address is done by the memory management unit (MMU) which is a hardware device.  

- Loading: Bringing the program from secondary memory to main memory is called Loading.
- Linking: Establishing the linking between all the modules or all the functions of the program in order to continue the program execution is called linking.

- At the time of loading, with static loading, the absolute program (and data) is loaded into memory in order for execution to start.
- If you are using dynamic loading, dynamic routines of the library are stored on a disk in relocatable form and are loaded into memory only when they are 
  needed by the program.

- When static linking is used, the linker combines all other modules needed by a program into a single executable program to avoid any runtime dependency.
- When dynamic linking is used, it is not required to link the actual module or library with the program, rather a reference to the dynamic module is provided 
  at the time of compilation and linking.
  
- Swapping
  Swapping is a mechanism in which a process can be swapped temporarily out of main memory (or move) to secondary storage (disk) and make that memory available to 
  other processes. At some later time, the system swaps back the process from the secondary storage to main memory. Though performance is usually affected by 
  swapping process but it helps in running multiple processes in parallel and that's the reason Swapping is also known as a technique for memory compaction. 
- The total time taken by swapping process includes the time it takes to move the entire process to a secondary disk and then to copy the process back to memory, 
  as well as the time the process takes to regain main memory.  
  
- Memory Allocation Techniques: Contiguous - fixed, dynamic. Non-contiguous - Paging, Segmentation

- External fragmentation :
  Total memory space is enough to satisfy a request or to reside a process in it, but it is not contiguous, so it cannot be used.
  External fragmentation can be reduced by compaction or shuffle memory contents to place all free memory together in one large block. To make compaction 
  feasible, relocation should be dynamic.
  
- Internal fragmentation :
  Memory block assigned to process is bigger. Some portion of memory is left unused, as it cannot be used by another process.
  The internal fragmentation can be reduced by effectively assigning the smallest partition but large enough for the process.  

- Paging is a memory management scheme that eliminates the need for contiguous allocation of physical memory. This scheme permits the physical address space 
  of a process to be non – contiguous.
- The Physical Address Space is conceptually divided into a number of fixed-size blocks, called frames.
- The Logical address Space is also splitted into fixed-size blocks, called pages.
- Page Size = Frame Size
- No need for external Fragmentation. Swapping is easy between equal-sized pages and page frames.
- Virtual memory ke concept se confuse na kr, usme process larger than main memory wala aata hai concept.
/ May cause Internal fragmentation.
/ Page tables consume additonal memory.

- Segmentation is another non-contiguous memory allocation scheme like paging. Like paging, in segmentation, process isn’t divided into mounted(fixed) size pages. 
  It is variable size partitioning theme. like paging, in segmentation, secondary and main memory are not divided into partitions of equal size. 
- https://www.geeksforgeeks.org/segmentation-in-operating-system/
- There is no simple relationship between logical addresses and physical addresses in segmentation. A table stores the information about all such segments 
  and is called Segment Table.
- Segment Table – It maps two-dimensional Logical address into one-dimensional Physical address. It’s each table entry has:
          Base Address: It contains the starting physical address where the segments reside in memory.
          Limit: It specifies the length of the segment.
- No Internal fragmentation.
- Segment Table consumes less space in comparison to Page table in paging.
/ May cause External fragmentation.

1. In paging, program is divided into fixed or mounted size pages. In segmentation, program is divided into variable size sections.
2. For paging operating system is accountable. For segmentation compiler is accountable.
4. It is faster in the comparison of segmentation. Segmentation is slow.
5. Paging could result in internal fragmentation. Segmentation could result in external fragmentation.
10. Paging is invisible to the user. Segmentation is visible to the user.

- Virtual Memory is a storage allocation scheme in which secondary memory can be addressed as though it were part of main memory. A computer can address more 
  memory than the amount physically installed on the system. This extra memory is actually called virtual memory. It is a technique that is implemented using 
  both hardware and software. It maps memory addresses used by a program, called virtual addresses, into physical addresses in computer memory.
          1. All memory references within a process are logical addresses that are dynamically translated into physical addresses at run time. This means that a 
             process can be swapped in and out of main memory such that it occupies different places in main memory at different times during the course of 
             execution.
          2. A process may be broken into number of pieces and these pieces need not be continuously located in the main memory during execution. The combination 
             of dynamic run-time address translation and use of page or segment table permits this.
- This means that the required pages need to be loaded into memory whenever required. Virtual memory is implemented using Demand Paging.
- Notebook.

- Demand Paging - The process of loading the page into memory on demand (whenever page fault occurs) demand paging. The basic idea behind demand paging is that 
  when a process is swapped in, its pages are not swapped in all at once. Rather they are swapped in only when the process needs them(On demand). 
  This is termed as lazy swapper.
- https://www.geeksforgeeks.org/virtual-memory-in-operating-system/ - see demanad paging steps.
- More processes may be maintained in the main memory.
- A process may be larger than all of main memory: One of the most fundamental restrictions in programming is lifted. 
- It allows greater multiprogramming levels by using less of the available (primary) memory for each process.

- In the given diagram, initial degree of multi programming upto some extent of point(lamda), the CPU utilization is very high and the system resources are 
  utilized 100%. But if we further increase the degree of multi programming the CPU utilization will drastically fall down and the system will spent more time 
  only in the page replacement and the time taken to complete the execution of the process will increase. This situation in the system is called as thrashing.

- Causes of Thrashing : - High degree of multiprogramming - Lacks of Frames  
- page replacement algos are used here.














