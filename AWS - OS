------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********
Linux Boot-up Process

An operating system (OS) is the low-level software that manages resources, controls peripherals, and provides basic services to other software.
In Linux, there are 6 distinct stages in the typical booting process.

1. BIOS - BIOS is firmware used to perform hardware initialization during the booting process, and to provide runtime services for operating systems and programs. 
          The BIOS firmware comes pre-installed on a personal computer's system board, and it is the first software to run when powered on. 

- BIOS stands for Basic Input/Output System
- Performs some system integrity checks
- Searches, loads, and executes the boot loader program.
- It looks for boot loader in floppy, cd-rom, or hard drive. You can press a key F12 of F2 during the BIOS startup to change the boot sequence.
- Once the boot loader program is detected and loaded into the memory, BIOS gives the control to it.
- So, in simple terms BIOS loads and executes the MBR boot loader.  

2. MBR
- MBR stands for Master Boot Record.
- It is located in the 1st sector of the bootable disk. Typically /dev/hda, or /dev/sda
- MBR is less than 512 bytes in size. This has three components 
    1) primary boot loader info in 1st 446 bytes 
    2) partition table info in next 64 bytes 
    3) mbr validation check in last 2 bytes.
- It contains information about GRUB (or LILO in old systems).
- So, in simple terms MBR loads and executes the GRUB boot loader.
- The MBR is the first sector of the computer hard drive that tells the computer how to load the operating system, 
  how the hard drive is partitioned.

3. GRUB/ LILO (Linux Loader)
- GRUB stands for Grand Unified Bootloader.
- If you have multiple kernel images installed on your system, you can choose which one to be executed.
- GRUB displays a splash screen, waits for few seconds, if you don’t enter anything, it loads the default kernel image as specified in the grub configuration file.
- GRUB has the knowledge of the filesystem (the older Linux loader LILO didn’t understand filesystem).
- Grub configuration file is /boot/grub/grub.conf (/etc/grub.conf is a link to this). 
- So, in simple terms GRUB just loads and executes Kernel and initrd images.

4. Kernel
  The Linux® kernel is the main component of a Linux operating system (OS) and is the core interface between a computer's hardware and its processes. It 
  communicates between the 2, managing resources as efficiently as possible.
- Mounts the root file system as specified in the “root=” in grub.conf
- Kernel executes the /sbin/init program
- Since init was the 1st program to be executed by Linux Kernel, it has the process id (PID) of 1.
- initrd stands for Initial RAM Disk.
- initrd is used by kernel as temporary root file system until kernel is booted and the real root file system is mounted. It also contains necessary drivers 
  compiled inside, which helps it to access the hard drive partitions, and other hardware.
- The kernel, if compressed (vmlinuz), will decompress itself. It then sets up system functions such as essential hardware and memory paging, and calls start_kernel() 
  which performs the majority of system setup (interrupts, the rest of memory management, device and driver initialization, etc.). 
  
5. Init
- Init is the parent of all processes, executed by the kernel during the booting of a system. Its principle role is to create processes from a script stored 
  in the file /etc/inittab.
- Looks at the /etc/inittab file to decide the Linux run level.
- Following are the available run levels
    0 – halt
    1 – Single user mode
    2 – Multiuser, without NFS
    3 – Full multiuser mode
    4 – unused
    5 – X11
    6 – reboot
- Init identifies the default initlevel from /etc/inittab and uses that to load all appropriate program.
- Execute ‘grep initdefault /etc/inittab’ on your system to identify the default run level
- Typically you would set the default run level to either 3 or 5.

6. Runlevel programs
- When the Linux system is booting up, you might see various services getting started. For example, it might say “starting sendmail …. OK”. Those are the 
  runlevel programs, executed from the run level directory as defined by your run level.
- Depending on your default init level setting, the system will execute the programs from one of the following directories.
    Run level 0 – /etc/rc.d/rc0.d/
    Run level 1 – /etc/rc.d/rc1.d/
    Run level 2 – /etc/rc.d/rc2.d/
    Run level 3 – /etc/rc.d/rc3.d/
    Run level 4 – /etc/rc.d/rc4.d/
    Run level 5 – /etc/rc.d/rc5.d/
    Run level 6 – /etc/rc.d/rc6.d/
- Programs starts with S are used during startup. S for startup.
- Programs starts with K are used during shutdown. K for kill.    
- A runlevel in other words can be defined as a preset single digit integer for defining the operating state of your LINUX or UNIX-based operating system. 
  Each runlevel designates a different system configuration and allows access to different combination of processes.  
  
 ** Unified Extensible Firmware Interface (UEFI) replaces BIOS.
    UEFI is packed with other features. It supports Secure Boot, which means the operating system can be checked for validity to ensure no malware has tampered 
    with the boot process. It can support networking features right in the UEFI firmware itself, which can aid in remote troubleshooting and configuration.  

------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********  
- An Operating System (OS) is an interface between a computer user and computer hardware. An operating system is a software which performs all the basic tasks like 
  file management, memory management, process management, handling input and output, and controlling peripheral devices such as disk drives and printers.

- https://www.tutorialspoint.com/operating_system/index.htm

*****************
Memory Management:
- Memory management is the functionality of an operating system which handles or manages primary memory and moves processes back and forth between main memory and 
  disk during execution. Memory management keeps track of each and every memory location, regardless of either it is allocated to some process or it is free. 
  It checks how much memory is to be allocated to processes. It decides which process will get memory at what time. It tracks whenever some memory gets freed or 
  unallocated and correspondingly it updates the status.

- https://www.geeksforgeeks.org/logical-and-physical-address-in-operating-system/#:~:text=Logical%20Address%20is%20generated%20by%20CPU%20while%20a%20program%20is%20running.&text=Physical%20Address%20identifies%20a%20physical,by%20its%20corresponding%20logical%20address.
- Virtual and physical addresses are the same in compile-time and load-time address-binding schemes. 
  Virtual and physical addresses differ in execution-time address-binding scheme.
- The set of all logical addresses generated by a program is referred to as a logical address space. The set of all physical addresses corresponding to these 
  logical addresses is referred to as a physical address space.
- The runtime mapping from virtual to physical address is done by the memory management unit (MMU) which is a hardware device.  

- Loading: Bringing the program from secondary memory to main memory is called Loading.
- Linking: Establishing the linking between all the modules or all the functions of the program in order to continue the program execution is called linking.

- At the time of loading, with static loading, the absolute program (and data) is loaded into memory in order for execution to start.
- If you are using dynamic loading, dynamic routines of the library are stored on a disk in relocatable form and are loaded into memory only when they are 
  needed by the program.

- When static linking is used, the linker combines all other modules needed by a program into a single executable program to avoid any runtime dependency.
- When dynamic linking is used, it is not required to link the actual module or library with the program, rather a reference to the dynamic module is provided 
  at the time of compilation and linking.
  
- Swapping
  Swapping is a mechanism in which a process can be swapped temporarily out of main memory (or move) to secondary storage (disk) and make that memory available to 
  other processes. At some later time, the system swaps back the process from the secondary storage to main memory. Though performance is usually affected by 
  swapping process but it helps in running multiple processes in parallel and that's the reason Swapping is also known as a technique for memory compaction. 
- The total time taken by swapping process includes the time it takes to move the entire process to a secondary disk and then to copy the process back to memory, 
  as well as the time the process takes to regain main memory.  
  
- Memory Allocation Techniques: Contiguous - fixed, dynamic. Non-contiguous - Paging, Segmentation

- External fragmentation :
  Total memory space is enough to satisfy a request or to reside a process in it, but it is not contiguous, so it cannot be used.
  External fragmentation can be reduced by compaction or shuffle memory contents to place all free memory together in one large block. To make compaction 
  feasible, relocation should be dynamic.
  
- Internal fragmentation :
  Memory block assigned to process is bigger. Some portion of memory is left unused, as it cannot be used by another process.
  The internal fragmentation can be reduced by effectively assigning the smallest partition but large enough for the process.  

- A page, memory page, or virtual page is a fixed-length contiguous block of virtual memory, described by a single entry in the page table. It is the smallest
  unit of data for memory management in a virtual memory operating system. Similarly, a page frame is the smallest fixed-length contiguous block of physical 
  memory into which memory pages are mapped by the operating system.

- In computer operating systems, paging is a memory management scheme by which a computer stores and retrieves data from secondary storage for use in main memory.
- Paging is a memory management scheme that eliminates the need for contiguous allocation of physical memory. This scheme permits the physical address space 
  of a process to be non – contiguous.
- The Physical Address Space is conceptually divided into a number of fixed-size blocks, called frames.
- The Logical address Space is also splitted into fixed-size blocks, called pages.
- Page Size = Frame Size
- No need for external Fragmentation. Swapping is easy between equal-sized pages and page frames.
- Virtual memory ke concept se confuse na kr, usme process larger than main memory wala aata hai concept.
/ May cause Internal fragmentation.
/ Page tables consume additonal memory.

- Segmentation is another non-contiguous memory allocation scheme like paging. Like paging, in segmentation, process isn’t divided into mounted(fixed) size pages. 
  It is variable size partitioning theme. like paging, in segmentation, secondary and main memory are not divided into partitions of equal size. 
- https://www.geeksforgeeks.org/segmentation-in-operating-system/
- There is no simple relationship between logical addresses and physical addresses in segmentation. A table stores the information about all such segments 
  and is called Segment Table.
- Segment Table – It maps two-dimensional Logical address into one-dimensional Physical address. It’s each table entry has:
          Base Address: It contains the starting physical address where the segments reside in memory.
          Limit: It specifies the length of the segment.
- No Internal fragmentation.
- Segment Table consumes less space in comparison to Page table in paging.
/ May cause External fragmentation.

1. In paging, program is divided into fixed or mounted size pages. In segmentation, program is divided into variable size sections.
2. For paging operating system is accountable. For segmentation compiler is accountable.
4. It is faster in the comparison of segmentation. Segmentation is slow.
5. Paging could result in internal fragmentation. Segmentation could result in external fragmentation.
10. Paging is invisible to the user. Segmentation is visible to the user.

- Virtual Memory is a storage allocation scheme in which secondary memory can be addressed as though it were part of main memory. A computer can address more 
  memory than the amount physically installed on the system. This extra memory is actually called virtual memory. It is a technique that is implemented using 
  both hardware and software. It maps memory addresses used by a program, called virtual addresses, into physical addresses in computer memory.
          1. All memory references within a process are logical addresses that are dynamically translated into physical addresses at run time. This means that a 
             process can be swapped in and out of main memory such that it occupies different places in main memory at different times during the course of 
             execution.
          2. A process may be broken into number of pieces and these pieces need not be continuously located in the main memory during execution. The combination 
             of dynamic run-time address translation and use of page or segment table permits this.
- This means that the required pages need to be loaded into memory whenever required. Virtual memory is implemented using Demand Paging.
- Notebook.

- Demand Paging - The process of loading the page into memory on demand (whenever page fault occurs) demand paging. The basic idea behind demand paging is that 
  when a process is swapped in, its pages are not swapped in all at once. Rather they are swapped in only when the process needs them(On demand). 
  This is termed as lazy swapper.
- https://www.geeksforgeeks.org/virtual-memory-in-operating-system/ - see demanad paging steps.
- More processes may be maintained in the main memory.
- A process may be larger than all of main memory: One of the most fundamental restrictions in programming is lifted. 
- It allows greater multiprogramming levels by using less of the available (primary) memory for each process.

- In the given diagram, initial degree of multi programming upto some extent of point(lamda), the CPU utilization is very high and the system resources are 
  utilized 100%. But if we further increase the degree of multi programming the CPU utilization will drastically fall down and the system will spent more time 
  only in the page replacement and the time taken to complete the execution of the process will increase. This situation in the system is called as thrashing.

- Causes of Thrashing : - High degree of multiprogramming - Lacks of Frames  
- page replacement algos are used here.

- Cache Memory is a special very high-speed memory. It is used to speed up and synchronizing with high-speed CPU. Cache memory is costlier than main memory or 
  disk memory but economical than CPU registers. It holds frequently requested data and instructions so that they are immediately available to the CPU when needed.
- Cache memory is used to reduce the average time to access data from the Main memory. The cache is a smaller and faster memory which stores copies of the data 
  from frequently used main memory locations.
  
- Primary Cache – A primary cache is always located on the processor chip. This cache is small and its access time is comparable to that of processor registers.
                  The L1 cache typically goes up to 256KB - 1MB.
- Secondary Cache – Secondary cache is placed between the primary cache and the rest of the memory. It is referred to as the level 2 (L2) cache. Often, 
                    the Level 2 cache is also housed on the processor chip. size = 256KB to 8MB.
- L3 (Level 3) cache is the largest cache memory unit, and also the slowest one. It can range between 4MB to upwards of 50MB. Modern CPUs have dedicated space on 
  the CPU for the L3 cache, and it takes up a large chunk of the space.       
- Locality of reference – Since size of cache memory is less as compared to main memory. So to check which part of main memory should be given priority and 
  loaded in cache is decided based on locality of reference.

- Types of Locality of reference :
- Spatial Locality of reference, this says that there is a chance that element will be present in the close proximity to the reference point and next time if 
  again searched then more close proximity to the point of reference.
- Temporal Locality of reference, in this Least recently used algorithm will be used. Whenever there is page fault occurs within a word will not only load word
  in main memory but complete page fault will be loaded because spatial locality of reference rule says that if you are referring any word next word will be
  referred in its register that’s why we load complete page table so the complete block will be loaded.

- Buffering – The main memory has an area called buffer that is used to store or hold the data temporarily that is being transmitted either between two devices 
  or between a device or an application. Buffering is an act of storing data temporarily in the buffer. It helps in matching the speed of the data stream between 
  the sender and the receiver. If the speed of the sender’s transmission is slower than the receiver, then a buffer is created in the main memory of the 
  receiver, and it accumulates the bytes received from the sender and vice versa.
  
- Single buffer : A buffer is provided by the operating system to the system portion of the main memory.
- Double buffer : There are two buffers in the system. One buffer is used by the driver or controller to store data while waiting for it to be taken by higher 
   level of the hierarchy. Other buffer is used to store data from the lower level module.
- Circular buffer : `When more than two buffers are used, the collection of buffers is itself referred to as a circular buffer.   
- Example – In printers spoolers, we can pass a large no of pages to print as input, but the processing/printing is slow. Here buffering is used.

- Buffer stores data till it is processed. Caching fastens the data access speed of repeatedly used data.
- Buffer stores original data. Cache stores copy of the data.
- First in First out. Least recently used Cache.
- Buffer is in block sizes like 4, 8, 16 so on, i.e, reading a single character will be same as reading the whole block. 
  Read and write is same as the normal storage.

- NTP stands for Network Time Protocol, and it is an Internet protocol used to synchronize the clocks of computers to some time reference. NTP is an 
  Internet standard protocol originally developed by Professor David Mills. It basically allow network devices to synchronize their clocks with a central source 
  clock. It makes sure that logging info and timestamps have accurate time and date.
- NTP uses UDP on port 123.
- NTP is intended to synchronize all participating computers to within a few milliseconds.
- If we have a device that is configured to multiple NTP servers, then we prefer a NTP server with lower stratum number.
- ex - allowance of social media access to clg sites after clg hours.
- Just imagine some EMail message arrived five minutes before it was sent, and there even was a reply two minutes before the message was sent.
- NTP uses UTC as reference time.
- Stratum 1 is in sync with a atomic clock. 

- Hardware time: - This time is provided by the hardware clock. Computer motherboards come with a pre-installed and configured hardware clock.
                   Hardware clock is the battery powered "Real Time Clock" (also known as the "RTC") which keeps track of time when the system 
                   is turned off but is not used when the system is running. A personal computer has a battery driven hardware clock. The battery ensures that 
                   the clock will work even if the rest of the computer is without electricity. Cmd - hwclock, to see the hw time, 
                   CMD - hwclock -w, to chnge hw time to sys time. 
                   The kernel clock always shows universal time. 
- System time: - This time is provided by the system clock. The system clock is installed by the operating system during the installation of the OS.
                 During the boot, Linux sets its own clock to the same time as the hardware clock. After this, both clocks run independently. Linux maintains 
                 its own clock because looking at the hardware is slow and complicated. Cmd -date, 
                 CMD - timedatectl set-ntp yes, to set sys time to ntp time.
- Network time: - This time is provided by an NTP server. An NTP server provides an accurate and reliable time using an atomic clock or an NTP server connected 
                  with an atomic clock. Network time is used to sync the system clock and hardware clock. Since the network time is provided by the external 
                  NTP server, you cannot change it.
- timedatectl set-time 'yyyy-mm-dd hh:mm:ss' to change hw-sw time.

------------------------------------------------------------------------------------------------------------------------------------------------------------------
********** 
User and Group Management:
- There are three types of accounts on a Unix system −

1. Root account
   This is also called superuser and would have complete and unfettered control of the system. A superuser can run any commands without any restriction. 
   This user should be assumed as a system administrator.

2. System accounts
   System accounts are those needed for the operation of system-specific components for example mail accounts. These accounts are usually 
   needed for some specific function on your system, and any modifications to them could adversely affect the system.

3. User accounts
   User accounts provide interactive access to the system for users and groups of users. General users are typically assigned to these accounts and usually have 
   limited access to critical system files and directories.

- There are four main user administration files −

- cat /etc/passwd − Keeps the user account and password information. This file holds the majority of information about accounts on the Unix system.

- /etc/shadow − Holds the encrypted password of the corresponding account. Not all the systems support this file.

- /etc/group − This file contains the group information for each account.

- /etc/gshadow − This file contains secure group account information.

- https://www.tutorialspoint.com/unix/unix-user-administration.htm

- After installation of the operating system, the ID 0 is assigned to the root user and the IDs 1 to 999 (both inclusive) are assigned to the system users 
  and hence the ids for local user begins from 1000 onwards. In a single directory, we can create 60,000 users.
  
- cat /etc/passwd - gives users list. format - [username]:[x]:[UID]:[GID]:[Comment]:[Home directory]:[Default shell]
- id username - gives id of a particular username
- sudo useradd username - add new user
- passwd username - assign new password to user
- sudo usermod -g/-d - Modify the group ID of a user/command to change the home directory
- userdel -r username - delete a user name

- There are 2 categories of groups in the Linux operating system i.e. Primary and Secondary groups. The Primary Group is a group that is automatically generated 
  while creating a user with a unique user ID simultaneously a group with ID same as the user ID is created and the user gets added to the group and becomes the 
  first and only member of the group. This group is called the primary group. The secondary group is a group that can be created separately with the help of 
  commands and we can then add users to it by changing the group ID of users.

- groupadd group_name -  Command to Make a group (Secondary Group)
- gpasswd group_name -  Command to Set the Password for the Group
- usermod -G group_name  username -  Command to Add a User to an Existing Group
- usermod -aG group_name username -  Command to Add User to Group Without Removing From Existing Groups
- gpasswd -d username1 group_name - Command to Delete a User From a Group
- groupdel group_name - del grp
- groupmod -n new_modified_group_name old_group_name - change name

------------------------------------------------------------------------------------------------------------------------------------------------------------------
********** 
32 - 64 bit Linux:

- uname (short for unix name) is a computer program in Unix and Unix-like computer operating systems that prints the name, version and other details about the 
  current machine and the operating system running on it. uname : linux, uname -m : linux_32/64, unmae -a : every info.
- lscpu - for indepth info about linux.   

1. It depends on the processor
   There are 2 major types of processors available, 32-bit and 64-bit processors. A 64-bit processor can run both 32 and 64-bit operating systems, however, 
   a 32-bit processor can only run 32-bit operating systems. 64 bit is backwards compatible.
2. The difference is that a 32-bit system can process 32 bits in one cycle, similar a 64-bit system can process 64 bits in one cycle.   
3. The major difference is that in a 32-bit system you will be able to use only 2^32 bytes of RAM which is around 4GB. Similarly, for 64-bit systems, you can use 
   up-to 16 Exa-Bytes of RAM. Though physical restrictions are there. 

------------------------------------------------------------------------------------------------------------------------------------------------------------------
********** 
GRUB:
- GNU GRUB (short for GNU Grand Unified Bootloader, commonly referred to as GRUB) is a boot loader package from the GNU Project. GRUB is the one which provides a 
  user the choice to boot one of multiple operating systems installed on a computer or select a specific kernel configuration available on a particular operating 
  system's partitions.
- GRUB is often used as a OS picker on startup for dual-boot computers, for instance, where one system is Linux and the other Windows.
- 3 interfaces - 
  Menu Interface : The GRUB is configured by the installation program in the menu interface. It is the default interface available.
  Menu Entry Editor Interface
  Command Line Interface
- The booting options such as kernel parameters can be modified using the GRUB command line.
- So, in simple terms GRUB just loads and executes Kernel and initrd images.

------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********
File Permissions:

- In Linux, most of the operations are performed on files. And to handle these files Linux has directories also known as folders which are maintained in a 
  tree-like structure.
  1. Regular Files: It is the common file type in Linux. it includes files like – text files, images, binary files, etc. Such files can be created using the 
                    touch command. They consist of the majority of files in the Linux/UNIX system. The regular file contains ASCII or Human Readable text.
  2. Directories:   These are the files that store the list of file names and the related information. The root directory(/) is the base of the system, /home/ is the default location for user’s home directories, 
                    /bin for Essential User Binaries, /boot – Static Boot Files, etc. We could create new directories with mkdir command.
  3. Special Files: Represents a real physical device such as a printer which is used for IO operations. Device or special files are used for device 
                    Input/Output(I/O) on UNIX and Linux systems. You can see them in a file system like an ordinary directory or file.
                    
- There are 2 ways to use the command -
  Absolute mode (numerical), Symbolic mode (rw-r-xrw-)                    
- ls -l : to get all the file details
- Final default directory permission: 755
- Final default file permission: 644
- chmod ugoa +-= rwx file_name
- chmod u=r,g=wx,o=rx [file_name] ======= chmod 435 [file_name]

Changing ownership
- -c: Reports when a file change is made. ----------- chown -c master file1.txt, it tells via a msg that ownership has changed
- Change the owner of file.
$ chown user1 sample.txt
- Change the group of file.
$ chown :mygroup file.txt
- Change both the owner and group of file in single command.
$ chown user1:mygroup file.txt

- chgrp command in Linux is used to change the group ownership of a file or directory. All files in Linux belong to an owner and a group. You can set the owner 
  by using “chown” command, and the group by the “chgrp” command. ex - sudo chgrp geeksforgeeks abc.txt
- sudo chgrp -R --reference=abc.txt GFG --- change dir name of GFG as of abc.txt

- Set-user-ID (SUID)
  In Linux by default when a user executes a file, The file gets executed with the privileges of the user who executes it. If we set SUID(set-user-ID) bit on the
  executable this behavior can be changed, then the file will always run with privileges of the owner of the file, no matter who runs the executable.
  You can set SUID bit by passing u + s to the chmod command.
  Alternatively, you can use octal notional by prefixing “4” to the octal string. (like 4724 instead of 724).

- Set-group-ID bit on a file: Set-group-ID (SGID) is similar to SUID except that, an executable with SGID bit set runs with the privileges of the group 
  which owns of the file.
  You can set SGID bit by passing g + s to the chmod command:
  Alternatively, you can use octal notional by prefixing “2” to the octal string. (like 2755 instead of 755).

- If the sticky bit on a directory is set, subdirectories/Files under that directory can only be deleted by either owner of the file, owner of the directory, 
  or the root user. chmod 1777 abc.txt ----1 for sticky bit

------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********
managing s/w, ssh

------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********
System Services :

- A service is a program that runs in the background outside the interactive control of system users as they lack an interface. This in order to provide even
  more security, because some of these services are crucial for the operation of the operating system.
- On the other hand, in systems like Unix or Linux, the services are also known as daemons. Sometimes the name of these services or daemons ends with the letter 
  d. For example, sshd is the name of the service that handles SSH.
  
- Linux supports different ways to manage (start, stop, restart, enable auto-start at system boot, etc.) services, typically through a process or service manager.
  Most if not all modern Linux distributions now use the same process manager: systemd.

- systemctl : When you run the systemctl command without any arguments, it will display a list of all loaded systemd units (read the systemd documentation 
              for more information about systemd units) including services, showing their status (whether active or not).
- Print active services in human-readable form.
  systemctl list-units -t service

- Services status 
  Enabled services are currently running. They usually have no problems.
  Disabled services are not active but can be activated at any time without a problem.
  Masked services won’t run unless we take that property away from them.
  Static services will only be used in case another service or unit needs it.

- systemctl start name.service
- systemctl stop name.service
- systemctl restart name.service
- systemctl reload name.service
- systemctl status name.service

- Use the systemctl enable command to have systemd automatically start a service (or other type of unit) at bootup. The systemctl disable command disables a 
  services and stops it from starting automatically with your computer.
  systemctl enable name.service
  systemctl disable name.service

- You can “mask” a service or other unit to prevent it from starting up at all. You’ll need to unmask it before it can start in the future:
  systemctl mask name.service
  systemctl unmask name.service

- It is possible to verify which port is being used by a service. 
  sudo netstat -plnt

------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********
Background Process management :

- An instance of a program is called a Process. In simple terms, any command that you give to your Linux machine starts a new process.
- Types of Processes:
1. Foreground Processes: They run on the screen and need input from the user. For example Office Programs
2. Background Processes: They run in the background and usually do not need user input. For example Antivirus.

- If you start a foreground program/process from the terminal, then you cannot work on the terminal, till the program is up and running.
  Particular, data-intensive tasks take lots of processing power and may even take hours to complete. You do not want your terminal to be held up for such a 
  long time. To avoid such a situation, you can run the program and send it to the background so that terminal remains available to you.

- Run a process by just typing its name, stop it by ctrl+Z.
- You can use the command "fg" to continue a program which was stopped and bring it to the foreground. 
- You can use the command "bg" to continue a program which was stopped and send it to background.
- Top
  This utility tells the user about all the running processes on the Linux machine.

- ps : currently running process
- top is mostly used interactively, Resource Monitoring like top resources using cpu, memory usage and more.
- ps aux : non-interactive,could be used to see which processes you (or any other user) are running currently. which gives you a single snapshot.

- Kill - This command terminates running processes on a Linux machine.
  kill PID
- To find the PID of a process simply type
  pidof Process name

- You can tell your machine to prioritize processes as per your requirements.
  nice -n 'Nice value' process name

- DF : This utility reports the free disk space(Hard Disk) on all the file systems.
- free : Gives free RAM on your system
- How do I list only running processes on Linux - ps r

------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********
Network Protocols :

* FTP : File Transfer Protocol(FTP) is an application layer protocol which moves files between local and remote file systems. It runs on the top of TCP, like HTTP. 
      To transfer a file, 2 TCP connections are used by FTP in parallel: control connection and (for identification of user, password) - 21 port number
      data connection (actual file transfer) - 20 port number.

- When a FTP session is started between a client and a server, the client initiates a control TCP connection with the server side. The client sends control 
  information over this. When the server receives this, it initiates a data connection to the client side. Only one file can be sent over one data connection. 
  But the control connection remains active throughout the user session. As we know HTTP is stateless i.e. it does not have to keep track of any user state. 
  But FTP needs to maintain a state about its user throughout the session.
- It dosen't encrypted data before sending.

- Structures supported by FTP :
  - File Structure – In file-structure there is no internal structure and the file is considered to be a continuous sequence of data bytes.
  - Record Structure – In record-structure the file is made up of sequential records.
  - Page Structure – In page-structure the file is made up of independent indexed pages.

- TFTP - Trivial FTP. Uses UDP instead of TCP. Dosen't use FTP feature. Sends only a simple file mostly during boot up process.
- SFTP stands for Secure File Transfer Protocol. It is a protocol which provides the secure channel, to transfer or copies the file from one host to another 
  host or systems. SFTP establishes the control connection under SSH protocol. It encrypted data before sending.
  
  
*  SMTP : Most of the internet systems use SMTP as a method to transfer mail from one user to another. SMTP is a push protocol and is used to send the mail 
          whereas POP (post office protocol) or IMAP (internet message access protocol) are used to retrieve those mails at the receiver’s side. 
 - SMTP servers commonly use the Transmission Control Protocol on port number 25.
 - SMTP is an application layer protocol. The client who wants to send the mail opens a TCP connection to the SMTP server and then sends the mail across the 
   connection. The SMTP server is always on listening mode. As soon as it listens for a TCP connection from any client, the SMTP process initiates a connection 
   on that port (25). After successfully establishing the TCP connection the client process sends the mail instantly. 

 - The SMTP model is of two type :
   End-to- end method, Store-and- forward method
   The end to end model is used to communicate between different organizations whereas the store and forward method are used within an organization. 
  
  
*  HTTP : HTTP stands for HyperText Transfer Protocol. It is invented by Tim Berner. HyperText is the type of text which is specially coded with the help of 
          some standard coding language called as HyperText Markup Language (HTML). The protocols that are used to transfer hypertext between two computers is 
          known as HyperText Transfer Protocol.

- HTTP provides standard between a web browser and web server to establish communication. It is set of rules for transferring data from one computer to another. 
  Data such as text, images, and other multimedia files are shared on the World Wide Web. Whenever a web user opens their browser, user will indirectly uses HTTP.

- How it works ?
  First of all, whenever we want to open any website then first we open web browser after that we will type URL of that website (e.g., www.facebook.com ). 
  This URL is now sent to Domain Name Server (DNS). Then DNS first check records for this URL in their database, then DNS will return IP address to web browser 
  corresponding to this URL. Now browser is able to sent request to actual server.
  After server sends data to client, connection will be closed. If we want something else from server we should have to re-establish connection between client 
  and server.

- It is stateless protocol because both client and server does not expecting anything from each other but they are still able to communicate.
- Since handshaking is done at initial connection stage, then latency is reduced because there is no further need of handshaking for subsequent requests.
/ HTTP is less secure, because it does not uses any encryption method like https use TLS to encryption.
/ A Stateless protocol implies that the HTTP Web Server does not maintains which request had originated from which user. Hence, to give a customized service to 
  the user, HTTP needs to use Cookies.

- HTTP uses port number 80 for communication and HTTPS uses 443
- HTTP is considered to be unsecure and HTTPS is secure
- HTTP Works at Application Layer and HTTPS works at Transport Layer
- In HTTP, Encryption is absent and Encryption is present in HTTPS as discussed above
- HTTP does not require any certificates and HTTPS needs SSL Certificates

