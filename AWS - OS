------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********
Linux Boot-up Process

An operating system (OS) is the low-level software that manages resources, controls peripherals, and provides basic services to other software.
In Linux, there are 6 distinct stages in the typical booting process.

1. BIOS - BIOS is firmware used to perform hardware initialization during the booting process, and to provide runtime services for operating systems and programs. 
          The BIOS firmware comes pre-installed on a personal computer's system board, and it is the first software to run when powered on. 

- BIOS stands for Basic Input/Output System
- Performs some system integrity checks
- Searches, loads, and executes the boot loader program.
- It looks for boot loader in floppy, cd-rom, or hard drive. You can press a key F12 of F2 during the BIOS startup to change the boot sequence.
- Once the boot loader program is detected and loaded into the memory, BIOS gives the control to it.
- So, in simple terms BIOS loads and executes the MBR boot loader.  

2. MBR
- MBR stands for Master Boot Record.
- It is located in the 1st sector of the bootable disk. Typically /dev/hda, or /dev/sda
- MBR is less than 512 bytes in size. This has three components 
    1) primary boot loader info in 1st 446 bytes 
    2) partition table info in next 64 bytes 
    3) mbr validation check in last 2 bytes.
- It contains information about GRUB (or LILO in old systems).
- So, in simple terms MBR loads and executes the GRUB boot loader.
- The MBR is the first sector of the computer hard drive that tells the computer how to load the operating system, 
  how the hard drive is partitioned.

3. GRUB/ LILO (Linux Loader)
- GRUB stands for Grand Unified Bootloader.
- If you have multiple kernel images installed on your system, you can choose which one to be executed.
- GRUB displays a splash screen, waits for few seconds, if you don’t enter anything, it loads the default kernel image as specified in the grub configuration file.
- GRUB has the knowledge of the filesystem (the older Linux loader LILO didn’t understand filesystem).
- Grub configuration file is /boot/grub/grub.conf (/etc/grub.conf is a link to this). 
- So, in simple terms GRUB just loads and executes Kernel and initrd images.

4. Kernel
  The Linux® kernel is the main component of a Linux operating system (OS) and is the core interface between a computer's hardware and its processes. It 
  communicates between the 2, managing resources as efficiently as possible.
- Mounts the root file system as specified in the “root=” in grub.conf
- Kernel executes the /sbin/init program
- Since init was the 1st program to be executed by Linux Kernel, it has the process id (PID) of 1.
- initrd stands for Initial RAM Disk.
- initrd is used by kernel as temporary root file system until kernel is booted and the real root file system is mounted. It also contains necessary drivers 
  compiled inside, which helps it to access the hard drive partitions, and other hardware.
- The kernel, if compressed (vmlinuz), will decompress itself. It then sets up system functions such as essential hardware and memory paging, and calls start_kernel() 
  which performs the majority of system setup (interrupts, the rest of memory management, device and driver initialization, etc.). 
  
5. Init
- Init is the parent of all processes, executed by the kernel during the booting of a system. Its principle role is to create processes from a script stored 
  in the file /etc/inittab.
- Looks at the /etc/inittab file to decide the Linux run level.
- Following are the available run levels
    0 – halt
    1 – Single user mode
    2 – Multiuser, without NFS
    3 – Full multiuser mode
    4 – unused
    5 – X11
    6 – reboot
- Init identifies the default initlevel from /etc/inittab and uses that to load all appropriate program.
- Execute ‘grep initdefault /etc/inittab’ on your system to identify the default run level
- Typically you would set the default run level to either 3 or 5.

6. Runlevel programs
- When the Linux system is booting up, you might see various services getting started. For example, it might say “starting sendmail …. OK”. Those are the 
  runlevel programs, executed from the run level directory as defined by your run level.
- Depending on your default init level setting, the system will execute the programs from one of the following directories.
    Run level 0 – /etc/rc.d/rc0.d/
    Run level 1 – /etc/rc.d/rc1.d/
    Run level 2 – /etc/rc.d/rc2.d/
    Run level 3 – /etc/rc.d/rc3.d/
    Run level 4 – /etc/rc.d/rc4.d/
    Run level 5 – /etc/rc.d/rc5.d/
    Run level 6 – /etc/rc.d/rc6.d/
- Programs starts with S are used during startup. S for startup.
- Programs starts with K are used during shutdown. K for kill.    
- A runlevel in other words can be defined as a preset single digit integer for defining the operating state of your LINUX or UNIX-based operating system. 
  Each runlevel designates a different system configuration and allows access to different combination of processes.  
  
 ** Unified Extensible Firmware Interface (UEFI) replaces BIOS.
    UEFI is packed with other features. It supports Secure Boot, which means the operating system can be checked for validity to ensure no malware has tampered 
    with the boot process. It can support networking features right in the UEFI firmware itself, which can aid in remote troubleshooting and configuration.  

------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********  
- An Operating System (OS) is an interface between a computer user and computer hardware. An operating system is a software which performs all the basic tasks like 
  file management, memory management, process management, handling input and output, and controlling peripheral devices such as disk drives and printers.

- https://www.tutorialspoint.com/operating_system/index.htm

*****************
Memory Management:
- Memory management is the functionality of an operating system which handles or manages primary memory and moves processes back and forth between main memory and 
  disk during execution. Memory management keeps track of each and every memory location, regardless of either it is allocated to some process or it is free. 
  It checks how much memory is to be allocated to processes. It decides which process will get memory at what time. It tracks whenever some memory gets freed or 
  unallocated and correspondingly it updates the status.

- https://www.geeksforgeeks.org/logical-and-physical-address-in-operating-system/#:~:text=Logical%20Address%20is%20generated%20by%20CPU%20while%20a%20program%20is%20running.&text=Physical%20Address%20identifies%20a%20physical,by%20its%20corresponding%20logical%20address.
- Virtual and physical addresses are the same in compile-time and load-time address-binding schemes. 
  Virtual and physical addresses differ in execution-time address-binding scheme.
- The set of all logical addresses generated by a program is referred to as a logical address space. The set of all physical addresses corresponding to these 
  logical addresses is referred to as a physical address space.
- The runtime mapping from virtual to physical address is done by the memory management unit (MMU) which is a hardware device.  

- Loading: Bringing the program from secondary memory to main memory is called Loading.
- Linking: Establishing the linking between all the modules or all the functions of the program in order to continue the program execution is called linking.

- At the time of loading, with static loading, the absolute program (and data) is loaded into memory in order for execution to start.
- If you are using dynamic loading, dynamic routines of the library are stored on a disk in relocatable form and are loaded into memory only when they are 
  needed by the program.

- When static linking is used, the linker combines all other modules needed by a program into a single executable program to avoid any runtime dependency.
- When dynamic linking is used, it is not required to link the actual module or library with the program, rather a reference to the dynamic module is provided 
  at the time of compilation and linking.
  
- Swapping
  Swapping is a mechanism in which a process can be swapped temporarily out of main memory (or move) to secondary storage (disk) and make that memory available to 
  other processes. At some later time, the system swaps back the process from the secondary storage to main memory. Though performance is usually affected by 
  swapping process but it helps in running multiple processes in parallel and that's the reason Swapping is also known as a technique for memory compaction. 
- The total time taken by swapping process includes the time it takes to move the entire process to a secondary disk and then to copy the process back to memory, 
  as well as the time the process takes to regain main memory.  
  
- Memory Allocation Techniques: Contiguous - fixed, dynamic. Non-contiguous - Paging, Segmentation

- External fragmentation :
  Total memory space is enough to satisfy a request or to reside a process in it, but it is not contiguous, so it cannot be used.
  External fragmentation can be reduced by compaction or shuffle memory contents to place all free memory together in one large block. To make compaction 
  feasible, relocation should be dynamic.
  
- Internal fragmentation :
  Memory block assigned to process is bigger. Some portion of memory is left unused, as it cannot be used by another process.
  The internal fragmentation can be reduced by effectively assigning the smallest partition but large enough for the process.  

- A page, memory page, or virtual page is a fixed-length contiguous block of virtual memory, described by a single entry in the page table. It is the smallest
  unit of data for memory management in a virtual memory operating system. Similarly, a page frame is the smallest fixed-length contiguous block of physical 
  memory into which memory pages are mapped by the operating system.

- In computer operating systems, paging is a memory management scheme by which a computer stores and retrieves data from secondary storage for use in main memory.
- Paging is a memory management scheme that eliminates the need for contiguous allocation of physical memory. This scheme permits the physical address space 
  of a process to be non – contiguous.
- The Physical Address Space is conceptually divided into a number of fixed-size blocks, called frames.
- The Logical address Space is also splitted into fixed-size blocks, called pages.
- Page Size = Frame Size
- No need for external Fragmentation. Swapping is easy between equal-sized pages and page frames.
- Virtual memory ke concept se confuse na kr, usme process larger than main memory wala aata hai concept.
/ May cause Internal fragmentation.
/ Page tables consume additonal memory.

- Segmentation is another non-contiguous memory allocation scheme like paging. Like paging, in segmentation, process isn’t divided into mounted(fixed) size pages. 
  It is variable size partitioning theme. like paging, in segmentation, secondary and main memory are not divided into partitions of equal size. 
- https://www.geeksforgeeks.org/segmentation-in-operating-system/
- There is no simple relationship between logical addresses and physical addresses in segmentation. A table stores the information about all such segments 
  and is called Segment Table.
- Segment Table – It maps two-dimensional Logical address into one-dimensional Physical address. It’s each table entry has:
          Base Address: It contains the starting physical address where the segments reside in memory.
          Limit: It specifies the length of the segment.
- No Internal fragmentation.
- Segment Table consumes less space in comparison to Page table in paging.
/ May cause External fragmentation.

1. In paging, program is divided into fixed or mounted size pages. In segmentation, program is divided into variable size sections.
2. For paging operating system is accountable. For segmentation compiler is accountable.
4. It is faster in the comparison of segmentation. Segmentation is slow.
5. Paging could result in internal fragmentation. Segmentation could result in external fragmentation.
10. Paging is invisible to the user. Segmentation is visible to the user.

- Virtual Memory is a storage allocation scheme in which secondary memory can be addressed as though it were part of main memory. A computer can address more 
  memory than the amount physically installed on the system. This extra memory is actually called virtual memory. It is a technique that is implemented using 
  both hardware and software. It maps memory addresses used by a program, called virtual addresses, into physical addresses in computer memory.
          1. All memory references within a process are logical addresses that are dynamically translated into physical addresses at run time. This means that a 
             process can be swapped in and out of main memory such that it occupies different places in main memory at different times during the course of 
             execution.
          2. A process may be broken into number of pieces and these pieces need not be continuously located in the main memory during execution. The combination 
             of dynamic run-time address translation and use of page or segment table permits this.
- This means that the required pages need to be loaded into memory whenever required. Virtual memory is implemented using Demand Paging.
- Notebook.

- Demand Paging - The process of loading the page into memory on demand (whenever page fault occurs) demand paging. The basic idea behind demand paging is that 
  when a process is swapped in, its pages are not swapped in all at once. Rather they are swapped in only when the process needs them(On demand). 
  This is termed as lazy swapper.
- https://www.geeksforgeeks.org/virtual-memory-in-operating-system/ - see demanad paging steps.
- More processes may be maintained in the main memory.
- A process may be larger than all of main memory: One of the most fundamental restrictions in programming is lifted. 
- It allows greater multiprogramming levels by using less of the available (primary) memory for each process.

- In the given diagram, initial degree of multi programming upto some extent of point(lamda), the CPU utilization is very high and the system resources are 
  utilized 100%. But if we further increase the degree of multi programming the CPU utilization will drastically fall down and the system will spent more time 
  only in the page replacement and the time taken to complete the execution of the process will increase. This situation in the system is called as thrashing.

- Causes of Thrashing : - High degree of multiprogramming - Lacks of Frames  
- page replacement algos are used here.

- Cache Memory is a special very high-speed memory. It is used to speed up and synchronizing with high-speed CPU. Cache memory is costlier than main memory or 
  disk memory but economical than CPU registers. It holds frequently requested data and instructions so that they are immediately available to the CPU when needed.
- Cache memory is used to reduce the average time to access data from the Main memory. The cache is a smaller and faster memory which stores copies of the data 
  from frequently used main memory locations.
  
- Primary Cache – A primary cache is always located on the processor chip. This cache is small and its access time is comparable to that of processor registers.
                  The L1 cache typically goes up to 256KB - 1MB.
- Secondary Cache – Secondary cache is placed between the primary cache and the rest of the memory. It is referred to as the level 2 (L2) cache. Often, 
                    the Level 2 cache is also housed on the processor chip. size = 256KB to 8MB.
- L3 (Level 3) cache is the largest cache memory unit, and also the slowest one. It can range between 4MB to upwards of 50MB. Modern CPUs have dedicated space on 
  the CPU for the L3 cache, and it takes up a large chunk of the space.       
- Locality of reference – Since size of cache memory is less as compared to main memory. So to check which part of main memory should be given priority and 
  loaded in cache is decided based on locality of reference.

- Types of Locality of reference :
- Spatial Locality of reference, this says that there is a chance that element will be present in the close proximity to the reference point and next time if 
  again searched then more close proximity to the point of reference.
- Temporal Locality of reference, in this Least recently used algorithm will be used. Whenever there is page fault occurs within a word will not only load word
  in main memory but complete page fault will be loaded because spatial locality of reference rule says that if you are referring any word next word will be
  referred in its register that’s why we load complete page table so the complete block will be loaded.

- Buffering – The main memory has an area called buffer that is used to store or hold the data temporarily that is being transmitted either between two devices 
  or between a device or an application. Buffering is an act of storing data temporarily in the buffer. It helps in matching the speed of the data stream between 
  the sender and the receiver. If the speed of the sender’s transmission is slower than the receiver, then a buffer is created in the main memory of the 
  receiver, and it accumulates the bytes received from the sender and vice versa.
  
- Single buffer : A buffer is provided by the operating system to the system portion of the main memory.
- Double buffer : There are two buffers in the system. One buffer is used by the driver or controller to store data while waiting for it to be taken by higher 
   level of the hierarchy. Other buffer is used to store data from the lower level module.
- Circular buffer : `When more than two buffers are used, the collection of buffers is itself referred to as a circular buffer.   
- Example – In printers spoolers, we can pass a large no of pages to print as input, but the processing/printing is slow. Here buffering is used.

- Buffer stores data till it is processed. Caching fastens the data access speed of repeatedly used data.
- Buffer stores original data. Cache stores copy of the data.
- First in First out. Least recently used Cache.
- Buffer is in block sizes like 4, 8, 16 so on, i.e, reading a single character will be same as reading the whole block. 
  Read and write is same as the normal storage.

- NTP stands for Network Time Protocol, and it is an Internet protocol used to synchronize the clocks of computers to some time reference. NTP is an 
  Internet standard protocol originally developed by Professor David Mills. It basically allow network devices to synchronize their clocks with a central source 
  clock. It makes sure that logging info and timestamps have accurate time and date.
- NTP uses UDP on port 123.
- NTP is intended to synchronize all participating computers to within a few milliseconds.
- If we have a device that is configured to multiple NTP servers, then we prefer a NTP server with lower stratum number.
- ex - allowance of social media access to clg sites after clg hours.
- Just imagine some EMail message arrived five minutes before it was sent, and there even was a reply two minutes before the message was sent.
- NTP uses UTC as reference time.
- Stratum 1 is in sync with a atomic clock. 

- Hardware time: - This time is provided by the hardware clock. Computer motherboards come with a pre-installed and configured hardware clock.
                   Hardware clock is the battery powered "Real Time Clock" (also known as the "RTC") which keeps track of time when the system 
                   is turned off but is not used when the system is running. A personal computer has a battery driven hardware clock. The battery ensures that 
                   the clock will work even if the rest of the computer is without electricity. Cmd - hwclock, to see the hw time, 
                   CMD - hwclock -w, to chnge hw time to sys time. 
                   The kernel clock always shows universal time. 
- System time: - This time is provided by the system clock. The system clock is installed by the operating system during the installation of the OS.
                 During the boot, Linux sets its own clock to the same time as the hardware clock. After this, both clocks run independently. Linux maintains 
                 its own clock because looking at the hardware is slow and complicated. Cmd -date, 
                 CMD - timedatectl set-ntp yes, to set sys time to ntp time.
- Network time: - This time is provided by an NTP server. An NTP server provides an accurate and reliable time using an atomic clock or an NTP server connected 
                  with an atomic clock. Network time is used to sync the system clock and hardware clock. Since the network time is provided by the external 
                  NTP server, you cannot change it.
- timedatectl set-time 'yyyy-mm-dd hh:mm:ss' to change hw-sw time.

------------------------------------------------------------------------------------------------------------------------------------------------------------------
********** 
User and Group Management:
- There are three types of accounts on a Unix system −

1. Root account
   This is also called superuser and would have complete and unfettered control of the system. A superuser can run any commands without any restriction. 
   This user should be assumed as a system administrator.

2. System accounts
   System accounts are those needed for the operation of system-specific components for example mail accounts. These accounts are usually 
   needed for some specific function on your system, and any modifications to them could adversely affect the system.

3. User accounts
   User accounts provide interactive access to the system for users and groups of users. General users are typically assigned to these accounts and usually have 
   limited access to critical system files and directories.

- There are four main user administration files −

- cat /etc/passwd − Keeps the user account and password information. This file holds the majority of information about accounts on the Unix system.

- /etc/shadow − Holds the encrypted password of the corresponding account. Not all the systems support this file.

- /etc/group − This file contains the group information for each account.

- /etc/gshadow − This file contains secure group account information.

- https://www.tutorialspoint.com/unix/unix-user-administration.htm

- After installation of the operating system, the ID 0 is assigned to the root user and the IDs 1 to 999 (both inclusive) are assigned to the system users 
  and hence the ids for local user begins from 1000 onwards. In a single directory, we can create 60,000 users.
  
- cat /etc/passwd - gives users list. format - [username]:[x]:[UID]:[GID]:[Comment]:[Home directory]:[Default shell]
- id username - gives id of a particular username
- sudo useradd username - add new user
- passwd username - assign new password to user
- sudo usermod -g/-d - Modify the group ID of a user/command to change the home directory
- userdel -r username - delete a user name

- There are 2 categories of groups in the Linux operating system i.e. Primary and Secondary groups. The Primary Group is a group that is automatically generated 
  while creating a user with a unique user ID simultaneously a group with ID same as the user ID is created and the user gets added to the group and becomes the 
  first and only member of the group. This group is called the primary group. The secondary group is a group that can be created separately with the help of 
  commands and we can then add users to it by changing the group ID of users.

- groupadd group_name -  Command to Make a group (Secondary Group)
- gpasswd group_name -  Command to Set the Password for the Group
- usermod -G group_name  username -  Command to Add a User to an Existing Group
- usermod -aG group_name username -  Command to Add User to Group Without Removing From Existing Groups
- gpasswd -d username1 group_name - Command to Delete a User From a Group
- groupdel group_name - del grp
- groupmod -n new_modified_group_name old_group_name - change name








